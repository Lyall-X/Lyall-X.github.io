---
layout: post
title: c++11新特性
categories: c++
description: c++11
keywords: c++, c++11
---

### 1.C+11总结

​	C++11标准为C++编程语言的第三个官方标准，正式名叫ISO/IEC 14882:2011 - Information technology -- Programming languages -- C++。在正式标准发布前，原名C++0x。它将取代C++标准第二版ISO/IEC 14882:2003 - Programming languages -- C++成为C++语言新标准。
​	C++11是对目前C++语言的扩展和修正， C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL） ，并入了大部分的C++ Technical Report 1（TR1） 程序库(数学的特殊函数除外)。
​	C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、 decltype，和模板的大量改进

------

### 2.类型推导

#### auto

​	auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替换为变量实际的类型

注意：

1. auto函数参数，有些编译器无法通过编译
2. auto非静态成员变量，无法通过编译
3. auto数组，无法通过编译
4. auto模板参数（实例化时），无法通过编译

#### decltype

​	decltype实际上有点像auto的反函数， auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到其类型

#### 追踪返回类型

​	返回类型后置：在函数名和参数列表后面指定返回类型

```cpp
auto func2(int, int) -> int;
auto mul(const T1 & t1, const T2 & t2) -> decltype(t1 * t2)
```

------

### 3.易用性的改进

#### 初始化

##### 列表初始化

​	初始化列表(List Initialize)

```cpp
Person p = {"Frank", 25};
std::vector<int> ivec3 = {1,2,3,4,5}; //不使用列表初始化用构造函数难以实现
```

##### 防止类型收窄

​	类型收窄指的是导致数据内容发生变化或者精度丢失的隐式类型转换。使用列表初始化可以防止类型收窄

​	类型精度变低后无法通过编译

#### 基于范围的for循环

​	使用基于范围的for循环，其for循环迭代的范围必须是可确定的；

​	参数不能是指针等

```cpp
int a[5] = { 1, 2, 3, 4, 5 };
for (int & e: a)
{
  e *= 2;
}
```

#### 静态断言

​	assert，这是一个宏，用于在运行阶段对断言进行检查，如果条件为真，执行程序，否则调用abort()

```cpp
#include <cassert>
//#include <assert.h>
//如果条件为真，程序正常执行，如果为假，终止程序，提示错误
assert(flag == true);
```

​	C++ 11新增了关键字static_assert，可用于在编译阶段对断言进行测试

静态断言的好处：

- 更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低
- 减少运行时开销，静态断言是编译期检测的，减少了运行时开销
- static_assert(常量表达式，提示字符串) //只能是常量表达式，不能是变量

#### noexcept修饰符

​	代表此函数不能抛出异常，如果抛出，就会异常

#### nullptr

​	为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0

```cpp
void func(int) {}
void func(int *) {}
//当函数调用func(NULL)是二义性
```

#### 强类型枚举

​	C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”

​	声明强类型枚举，只需要在enum后加上使用class或struct

“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突），它们会被隐式转换为整型，并且不可以指定枚举的底层数据类型

------

### 4.类的改进

#### 继承构造

​	C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）

注意：

- 继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量
- 如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数
- 一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数

```cpp
using A::A; // 继承构造函数
```

#### 委托构造

​	如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这必须通过初始化列表进行操作

```cpp
public:
    Info() : Info(1) { }    // 委托构造函数
    Info(int i) : Info(i, 'a') { } // 既是目标构造函数，也是委托构造函数
    Info(char e): Info(1, e) { }
private:
    Info(int i, char e): type(i), name(e) { /* 其它初始化 */ } // 目标构造函数
```

#### 继承控制：final和override

- final阻止类的进一步派生和虚函数的进一步重写；此类不能继承
- override确保在派生类中声明的函数跟基类的虚函数有相同的签名

#### 类默认函数的控制："=default" 和 "=delete"函数

=default 使用：

- 如果程序员为类显式的自定义了非默认构造函数，编译器将不再会为它隐式地生成默认无参构造函数
- 将该函数声明为 "=default"函数，编译器将为显式声明的 "=default"函数自动生成函数体
- "=default"函数特性仅适用于类的无参默认构造

=delete 使用：

- =delete 禁用函数
- "=delete"函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换
- "=delete"函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象(禁止堆创建对象)

------

### 5.模板的改进

#### 右尖括号>改进

​	编译器对模板的右尖括号做单独处理，使编译器能够正确判断出">>"是一个右移操作符还是模板参数表的结束标记

#### 模板的别名

​	std::is_same -- 判断两个类型是否一致

------

### 6.可变参数的模板

- 允许模板定义中包含0到任意个模板参数
- 可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“...”
- template<class ... T> void func(T ... args)//T叫模板参数包，args叫函数参数包

------

### 7.右值引用

#### 左值引用、右值引用

- 左值：可以取地址的、有名字的
- 右值：表示字面常量、表达式、函数的非引用返回值等
- 左值引用是对一个左值进行引用的类型，是具名变量值的别名
- 右值引用则是对一个右值进行引用的类型，是不具名（匿名）变量的别名

#### 移动语义

- 右值引用是用来支持转移语义的
- 能够减少不必要的临时对象的创建、拷贝以及销毁
- 转移语义是和拷贝语义相对的，通过转移语义，临时对象中的资源能够转移其它的对象里，拷贝语义对于临时对象耗费性能
- 标准库函数 std::move

#### 完美转发 std::forward

- 需要将一组参数原封不动的传递给另一个函数
- 所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样

------

### 8.智能指针

​	unique_ptr、shared_ptr与weak_ptr等智能指针

#### unique_ptr

​	持有对对象的独有权，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）

生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)

#### shared_ptr

​	允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除

#### weak_ptr

​	weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 * 和 -> 但可以使用lock获得一个可用的shared_ptr对象

​	可以指向shared_ptr指针指向的对象内存，却并不拥有该内存，而使用weak_ptr成员lock，则可返回其指向内存的一个share_ptr对象，且在所指对象内存已经无效时，返回指针空值nullptr

------

### 9.闭包的实现

​	函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包；闭包的状态捆绑，必须发生在运行时

#### 仿函数：重载 operator()

#### std::bind绑定器

#### lambda表达式

- 空 不使用任何函数对象参数
- = 值传递
- & 引用传递
- this 可以使用lambda所在类中的成员变量

------

### 10.线程

#### 线程的使用

​	用std::thread创建线程非常简单，只需要提供线程函数或函数对象即可，并且可以同时指定线程函数的参数;std::thread::join等待线程结束（此函数会阻塞），并回收线程资源，如果线程函数有返回值，返回值将被忽略

​	如果不希望线程被阻塞执行，可以调用线程的std::thread::detach，将线程和线程对象分离，让线程作为后台线程去执行。但需要注意的是，detach之后就无法在和线程发生联系了，比如detach之后就不能再通过join来等待执行完，线程何时执行完我们也无法控制

#### 互斥量

独占互斥量std::mutex

原子操作：似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高