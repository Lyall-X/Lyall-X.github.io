---
layout: post
title:  Protocol
categories: 网络
description: 协议设计
keywords: c++, proto
---

### 协议设计原则

游戏协议：流量小，对平台的支持足够多，解析效率高

设计原则：
- 语法：协议结构
- 语义：协议携带信息
- 时序：协议顺序


![1619411512786](\images\posts\proto\1619411512786.png)



#### 文本协议

 http协议为例

优点：

1. 通用，使用广泛
2. 方便理解，可读性好

缺点：

1. 基于行读，解析效率一般
2. 携带附带信息过多，传输的效率低下
3. 无状态，服务器不知道客户端的状态，必须基于客户端的请求来回应，实时性低
4. 很难嵌入其他数据，对二进制支持差

适用：

1. 游戏对流量要求不高
2. 短连接游戏



#### 二进制协议

二进制协议特征：

- 二进制协议就是一串字节流，是一个典型的 Ip 协议
- 一般通常包括消息头(header)和变长的消息体(body)，消息头的长度固定，消息体长度不固定，包含主要的内容主体
- 一般消息头会包含消息体的长度，这样就能基于头信息从数据流中解析出一个完整的二机制消息了


![1619411523413](\images\posts\proto\1619411523413.png)

协议头head结构：

- cmd:命令字
  - 双方协议规定好的，msg id
- sign：验证串
  - 对数据进行一定加密验证，保证数据安全
- content-leg:消息体长度
- HeaderCRC：头验证（不是必须）

协议体body结构：

```cpp
message login{
    string username;
    int64 passwoard;
}
```

优点：

1. 没有冗余字段，传输高效，耗费流量小
2. 解析速度快，基于基础数据类型操作

缺点：

1. 可读性差，不利于调试
2. 扩展性差，对复杂数据结构支持不够

适用：

1. 实时性高，流量要求
2. 大型网游



#### 数据格式

不同的消息格式解析方式不同：

- json
  - fastJson 常用的消息框架
  - 开源，格式统一
  - 缺点：冗余字符，不够简洁
- xml
  - 不建议，无效字符多
- protocolbuf
  - google提供的一个开源序列化框架
  - 占用空间小，没有冗余字段，解析速度快
  - 缺点：可读性差，不支持复杂数据结构
    - 官网： https://developers.google.com/protocol-buffers
    - 谷歌开发者中心： https://developers.google.com/products



#### 安全层 -> 协议加密

常规加密：

- 对称加密或者hash加密
- 两端采用同一种加密算法，基于同一个密钥对消息体进行加密换算，以此来查看数据是否一致
- 密钥获取方式(2种)
  - 密钥用户登陆的时候获取一次
  - 基于每个用户密钥不同，以此防止密钥泄露大范围影响全服玩家

动态加密：

- 提前设置一个私有密钥库，里面包含一定数量的密钥
- 每次请求时基于协议号设计算法获取其中一个密钥
- 即便其中一个被破解也没关系

其他：

- 非对称加密：加解密速度慢，耗时
- 加盐处理：随机值混在原始密码中，电脑也不知道原始密码，再次输入密码时会以相同的方式加盐，最后与原来加盐后的密码比对



#### 传输层

- UDP比TCP传输快速
- TCP数据完整性，安全性行可靠性高
- 长连接采用分区分服，短连接采用分布式

![1619411797191](\images\posts\proto\1619411797191.png)

------

### 协议设计问题

#### 字节序

- 大端 Big endian
- 小端 Little endian

跨语言，平台通讯会出现乱码
解决方法：客户端和服务端强制采用一种字节序，一般采用网络字节序（大端 Big endian）

#### 浮点数

浮点数多平台运算不一致

解决办法：

- 统一一种格式，比如前后端都采用软模拟，或者强制采用硬件IEEE-754（软模拟速度慢）
- 转换为定点数，也就是浮点转换为整数（速度快）

#### 粘包与拆包

粘包现象：

- Nagel : 40ms
- 如果是一个小包（ < MSS ），则等待40ms
- 如果在40ms中间，有其他的包要发送，那就组包，mtu
- 如果到了40ms，没有其他的包，则超时后，发送msg1

tcp是面向安全的流式传输，包的概念怎么来?

1. 数据在TCP层 “流” 的时候为了保证安全和节约效率会把 “流” 做一些分包处理
2. 拆包：发送方约定了每次数据传输的最大包大小，超过该值的内容将会被拆分成两个包发送
3. 发送端 和 接收端 约定每次发送数据包长度并随着网络状况动态调整接收窗口大小，这里也会出现拆包的情况

tcp出现粘包/拆包的原因：数据流在tcp下传播，因为对数据流的限制，导致对端收到的数据包不完整

- Socket 缓冲区与滑动窗口
- MSS/MTU 限制
- Nagle 算法

解决方法：

- 定长协议：
  - 指定一个报文具有固定长度
  - 不足部分用空格补齐
  - 缺点：浪费带宽
- 特殊字符分割协议：
  - 一个完整的包的尾部添加指定的特殊字符，比如：\n，\r
  - 约定的特殊字符要保证唯一性，不能出现在报文的正文中，否则就将正文一分为二了
- 变长协议：
  - 将消息分为消息头和消息体，消息头中标识当前完整的消息体长度
  - 发送方在发送数据之前先获取数据的二进制字节大小，然后在消息体前面添加消息大小
  - 接收方在解析消息时先获取消息大小，之后必须读到该大小的字节数才认为是完整的消息



### 基于udp的可靠传输

- 实现方式
- 开源框架



### Netty源码分析