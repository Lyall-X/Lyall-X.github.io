---
layout: post
title:  Protocol
categories: 网络
description: 协议设计
keywords: c++, proto
---

### 协议设计原则

游戏协议：流量小，对平台的支持足够多，解析效率高

设计原则：
- 语法：协议结构
- 语义：协议携带信息
- 时序：协议顺序


![1619411512786](\images\posts\proto\1619411512786.png)



#### 文本协议

 http协议为例

优点：

1. 通用，使用广泛
2. 方便理解，可读性好

缺点：

1. 基于行读，解析效率一般
2. 携带附带信息过多，传输的效率低下
3. 无状态，服务器不知道客户端的状态，必须基于客户端的请求来回应，实时性低
4. 很难嵌入其他数据，对二进制支持差

适用：

1. 游戏对流量要求不高
2. 短连接游戏



#### 二进制协议

二进制协议特征：

- 二进制协议就是一串字节流，是一个典型的 Ip 协议
- 一般通常包括消息头(header)和变长的消息体(body)，消息头的长度固定，消息体长度不固定，包含主要的内容主体
- 一般消息头会包含消息体的长度，这样就能基于头信息从数据流中解析出一个完整的二机制消息了


![1619411523413](\images\posts\proto\1619411523413.png)

协议头head结构：

- cmd:命令字
  - 双方协议规定好的，msg id
- sign：验证串
  - 对数据进行一定加密验证，保证数据安全
- content-leg:消息体长度
- HeaderCRC：头验证（不是必须）

协议体body结构：

```cpp
message login{
    string username;
    int64 passwoard;
}
```

优点：

1. 没有冗余字段，传输高效，耗费流量小
2. 解析速度快，基于基础数据类型操作

缺点：

1. 可读性差，不利于调试
2. 扩展性差，对复杂数据结构支持不够

适用：

1. 实时性高，流量要求
2. 大型网游



#### 数据格式

不同的消息格式解析方式不同：

- json
  - fastJson 常用的消息框架
  - 开源，格式统一
  - 缺点：冗余字符，不够简洁
- xml
  - 不建议，无效字符多
- protocolbuf
  - google提供的一个开源序列化框架
  - 占用空间小，没有冗余字段，解析速度快
  - 缺点：可读性差，不支持复杂数据结构
    - 官网： https://developers.google.com/protocol-buffers
    - 谷歌开发者中心： https://developers.google.com/products



#### 安全层 -> 协议加密

常规加密：

- 对称加密或者hash加密
- 两端采用同一种加密算法，基于同一个密钥对消息体进行加密换算，以此来查看数据是否一致
- 密钥获取方式(2种)
  - 密钥用户登陆的时候获取一次
  - 基于每个用户密钥不同，以此防止密钥泄露大范围影响全服玩家

动态加密：

- 提前设置一个私有密钥库，里面包含一定数量的密钥
- 每次请求时基于协议号设计算法获取其中一个密钥
- 即便其中一个被破解也没关系

其他：

- 非对称加密：加解密速度慢，耗时
- 加盐处理：随机值混在原始密码中，电脑也不知道原始密码，再次输入密码时会以相同的方式加盐，最后与原来加盐后的密码比对



#### 传输层

- UDP比TCP传输快速
- TCP数据完整性，安全性行可靠性高
- 长连接采用分区分服，短连接采用分布式

![1619411797191](\images\posts\proto\1619411797191.png)

------

### 协议设计问题

#### 字节序

- 大端 Big endian
- 小端 Little endian

跨语言，平台通讯会出现乱码
解决方法：客户端和服务端强制采用一种字节序，一般采用网络字节序（大端 Big endian）

#### 浮点数

浮点数多平台运算不一致

解决办法：

- 统一一种格式，比如前后端都采用软模拟，或者强制采用硬件IEEE-754（软模拟速度慢）
- 转换为定点数，也就是浮点转换为整数（速度快）

#### 粘包与拆包

粘包现象：

- Nagel : 40ms
- 如果是一个小包（ < MSS ），则等待40ms
- 如果在40ms中间，有其他的包要发送，那就组包，mtu
- 如果到了40ms，没有其他的包，则超时后，发送msg1

tcp是面向安全的流式传输，包的概念怎么来?

1. 数据在TCP层 “流” 的时候为了保证安全和节约效率会把 “流” 做一些分包处理
2. 拆包：发送方约定了每次数据传输的最大包大小，超过该值的内容将会被拆分成两个包发送
3. 发送端 和 接收端 约定每次发送数据包长度并随着网络状况动态调整接收窗口大小，这里也会出现拆包的情况

tcp出现粘包/拆包的原因：数据流在tcp下传播，因为对数据流的限制，导致对端收到的数据包不完整

- Socket 缓冲区与滑动窗口
- MSS/MTU 限制
- Nagle 算法

解决方法：

- 定长协议：
  - 指定一个报文具有固定长度
  - 不足部分用空格补齐
  - 缺点：浪费带宽
- 特殊字符分割协议：
  - 一个完整的包的尾部添加指定的特殊字符，比如：\n，\r
  - 约定的特殊字符要保证唯一性，不能出现在报文的正文中，否则就将正文一分为二了
- 变长协议：
  - 将消息分为消息头和消息体，消息头中标识当前完整的消息体长度
  - 发送方在发送数据之前先获取数据的二进制字节大小，然后在消息体前面添加消息大小
  - 接收方在解析消息时先获取消息大小，之后必须读到该大小的字节数才认为是完整的消息



### 基于udp的可靠传输

- 实现方式
- 开源框架

------

### Netty源码分析

------

## Protobuf

**protobuf序列化**

---

* protobuf是一种比json和xml等序列化工具更加轻量和高效的结构化数据存储格式，性能比json和xml真的强很多，毕竟是google出品的
* [protocol buffer官网](https://developers.google.com/protocol-buffers/)

---

### protobuf的安装

```
$ git clone https://github.com/protocolbuffers/protobuf.git
$ cd protobuf
$ git submodule update --init --recursive
$ ./autogen.sh
$ ./configure
$ make
$ make check
$ sudo make install
$ sudo ldconfig
```

---

### protobuf的应用

定义message

* message必须定义到一个文件中，且文件的后缀名为.proto

编译message文件

* protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto
* SRC_DIR 表示proto文件所在的目录，cpp_out指定了生成的代码的路径，$SRC_DIR/addressbook.proto指proto文件。
* 例如：protoc -I=./ --cpp_out=./ protocol.proto

---

**应用protobuf**

* AIP说明文档：

---

### protobuf的原理

![39f3a29174ab19041b2ac57ef4fe33d9.png](\images\posts\proto\39f3a29174ab19041b2ac57ef4fe33d9.png)

---

### proto2和proto3的区别

总的来说，proto3 比 proto2 支持更多语言但 更简洁。去掉了一些复杂的语法和特性，更强调约定而弱化语法。如果是首次使用 Protobuf ，建议使用 proto3 。

1. 在第一行非空白非注释行，必须写： syntax = "proto3"; 字段规则移除了 “required”，并把 “optional” 改名为 “singular”1；
2. 在 proto2 中 required 也是不推荐使用的。proto3 直接从语法层面上移除了 required 规则。其实可以做的更彻底，把所有字段规则描述都撤销，原来的 repeated 改为在类型或字段名后加一对中括号。这样是不是更简洁？
3. repeated”字段默认采用 packed 编码； 在 proto2 中，需要明确使用 [packed=true] 来为字段指定比较紧凑的 packed 编码方式。
4. 语言增加 Go、Ruby、JavaNano 支持；
5. 移除了 default 选项； 在 proto2 中，可以使用 default 选项为某一字段指定默认值。在 proto3 中，字段的默认值只能根据字段类型由系统决定。也就是说，默认值全部是约定好的，而不再提供指定默认值的语法。 在字段被设置为默认值的时候，该字段不会被序列化。这样可以节省空间，提高效率。 但这样就无法区分某字段是根本没赋值，还是赋值了默认值。这在 proto3 中问题不大，但在 proto2 中会有问题。 比如，在更新协议的时候使用 default 选项为某个字段指定了一个与原来不同的默认值，旧代码获取到的该字段的值会与新代码不一样。 另一个重约定而弱语法的例子是 Go 语言里的公共/私有对象。Go 语言约定，首字母大写的为公共对象，否则为私有对象。所以在 Go 语言中是没有 public、private 这样的语法的。
6. 枚举类型的第一个字段必须为 0 ； 这也是一个约定。
7. 移除了对分组的支持； 分组的功能完全可以用消息嵌套的方式来实现，并且更清晰。在 proto2 中已经把分组语法标注为『过期』了。这次也算清理垃圾了。
8. 旧代码在解析新增字段时，会把不认识的字段丢弃，再序列化后新增的字段就没了； 在 proto2 中，旧代码虽然会忽视不认识的新增字段，但并不会将其丢弃，再序列化的时候那些字段会被原样保留。 我觉得还是 proto2 的处理方式更好一些。能尽量保持兼容性和扩展能力，或许实现起来也更简单。proto3 现在的处理方式，没有带来明显的好处，但丢掉了部分兼容性和灵活性。 经过漫长的讨论，官方终于同意在 proto3 中恢复 proto2 的处理方式了。 可以通过这个文档了解前因后果及时间线。
9. 移除了对扩展的支持，新增了 Any 类型； Any 类型是用来替代 proto2 中的扩展的。目前还在开发中。 proto2 中的扩展特性很像 Swift 语言中的扩展。理解起来有点困难，使用起来更是会带来不少混乱。 相比之下，proto3 中新增的 Any 类型有点像 C/C++ 中的 void* ，好理解，使用起来逻辑也更清晰。
10. 增加了 JSON 映射特性； 语言的活力来自于与时俱进。当前，JSON 的流行有其充分的理由。很多『现代化』的语言都内置了对 JSON 的支持，比如 Go、PHP 等。而 C++ 这种看似保罗万象的学院派语言，因循守旧、故步自封，以致于现出了式微的苗头。