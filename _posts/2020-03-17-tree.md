---
layout: post
title: 树
categories: 数据结构与算法
description: 树
keywords: 二叉树, 树
---

## 二叉树与红黑树

### 树的分类

#### 二叉树

 每个节点最多有两个子树的树结构

* 在非空二叉树中，第i层的结点总数不超过 2^(i-1) , i>= 1;
* 深度为h的二叉树最多有2^-1 个结点(h >= 1)，最少有h个结点；
* 对于任意一颗二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1
* 具有n个结点的完全二叉树的深度 [log 2 n] + 1，（注:[ ] 表示向下取整）。
* 有N个结点的完全二叉树各结点如果用顺序方式存储。则结点之间有如下关系：
    * 若i为结点编号则 如果i>1, 则其父结点的编号为i>2;
    * 如果2*I <= N , 则其左儿子的编号为2*I, 若2*i>N, 则无左儿子
    * 如果2*i+1 <= N, 则其右儿子的结点编号为2*i+1; 若2*i+1 > N, 则无右儿子。

---

#### bst二叉搜索树

二叉搜索树是二叉树的特例;同时也很高级结构变种AVL

* 若左子树不为空，则左子树上所有结点的值均小于或者等于它的根结点的值。
* 若右子树不为空，则右子树上所有结点的值均大于或者等于它的根结点的值
* 左右子树也分别为二叉排序树

---

#### 红黑树

根据二叉排序树生成的

* 红黑树不同于二叉排序的重要原因就是能够自动均衡左右子树的高度。如何均衡左右子树的高度：通过旋转
* 不论左旋还是右旋，都需要修改三个方向指针，六个指针变量

红黑树的插入：在插入之前，两点的确定的

* 未插入当前结点以前的红黑树是已经满足了红黑树的所有条件，是一颗红黑树的
* 当前结点是红色的

红黑树的特点：由特点产生的推论

* ![4005cdb233dc85976ab99574f093196e.png](\images\posts\algorithm\4005cdb233dc85976ab99574f093196e.png)
* 结点更改后，只需要判断祖父结点到叶子结点的黑色结点一样多就满足性质了
* 由于当前结点是红色的，只有父节点是红色，才需要调整。所以能确定了当前结点x是红色的，父节点是红色的，祖父结点肯定是黑色的，那叔父结点是红色或者黑色。

------

### 红黑树应用

```
案例一、服务器端高并发IO的keep alilve方案，满足一下几个需求
1. 每个IO都是自己的时间戳
2. 每个IO收到自己的beat(心跳包)后，重置自己的定时器
3. 若IO定时没有收到beat，则执行IO的回调函数，并重置定时器
4. 若再次没有收到beat，销毁IO，注销定时器。
```

#### keepalived

* 服务器和客户端定时发送心跳包
* 当服务器所长连接的对象宕机了，可以立即知道宕机的对象
* 服务器高并发下，很多个io，这时keepalived如何设计
* 如果简单的遍历IO数组，不是最好的方案
* 高并发100Wscket，如何排序
* 红黑树：时间戳当key，IO当value

解决思路：

![87c0fa7a51e7671da2ab19164c789409.png](\images\posts\algorithm\87c0fa7a51e7671da2ab19164c789409.png)

* 每次来个io都插入到树里；二叉排序树状态不稳定，最坏的情况成链表了

```
案例一、服务器端高并发IO的keep alilve方案，满足一下几个需求
1. 每个IO都是自己的时间戳
2. 每个IO收到自己的beat后，重置自己的定时器
3. 若IO定时没有收到beat，则执行IO的回调函数，并重置定时器
4. 若再次没有收到beat，销毁IO，注销定时器。
```

* 运行体与结构体的状态如何保存从

---

* 平衡二叉树是为每一个子节点加上了左右子树的高度
* 红黑树为每一个节点增加了一个颜色

#### 红黑树案例

一般是将时间戳当作key

* Linux进程调度CFS，时间片调度
* NginxTimer事件管理
* Epoll事件块管理
* 时间冲突的话，加一丢丢时间
* 遵循小于节点的数放节点左边，大于节点的数放在节点右边

在新增加一个节点的时候，这棵树是满足红黑树性质的。

树的左旋：

* ![10fdf6d7cd1ea89823cfb8bfe644958a.png](\images\posts\algorithm\10fdf6d7cd1ea89823cfb8bfe644958a.png)