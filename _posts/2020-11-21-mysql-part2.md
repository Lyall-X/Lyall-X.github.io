---
layout: post
title: Mysql (part 2)
categories: Mysql
description: 数据库存储原理
keywords: mysql
---

### Mysql存储原理

#### 数据结构：

##### 树相关：

* 二叉树：查找的时间复杂度为 O(logN)
* 平衡二叉树：防止二叉树退化成链表导致查询速度成 O(n)
* 红黑树：平衡二叉树要求太严，每次要左旋和右旋来进行调整
* B树：多叉树（平衡多路查找树） 数据库常用
* B+树： B 树的一个升级版，更充分的利用了节点的空间，让查询速度更加稳定

##### B树与B+树区别：

* B+树中只有叶子节点会带有指向记录的指针（ROWID），
* B+树中所有叶子节点都是通过指针连接在一起，而B树不会

##### B+树的优点：

* 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点
* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动

##### B树的优点：

* 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位

------

#### 存储原理

* 为了提高查询速度，数据结构采用红黑树，复杂度为 logN
* 树太深的话也会耗费查询性能
* Mysql默认存储引擎采用B+树

---

![.png](\images\posts\mysql\.png)

##### B树（耗费性能）：

* 每个node节点都是一个磁盘块 4k
* 每个数据包含三项：键值Key，指针，数据
* 在 B-Tree 中，每个节点中有 key，也有 data，而每一个页的存储空间是有限的；
* 当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率

![-1.png](\images\posts\mysql\-1.png)

##### mysql结构B+树：

* 一类存储所有只有key的节点，一类存储data的节点
* 3次IO，存储的key就比较多，减少了查询速度
* 第一行一级索引，第二行二级索引

---

##### 数据库引擎：Myisam和InnoDB区别

MyIsam的B+树

![-2.png](\images\posts\mysql\-2.png)

InnoDB的B+树：

![-3.png](\images\posts\mysql\-3.png)

* InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一
* InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败
* InnoDB 是聚集索引，MyISAM 是非聚集索引
* InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁

![-4.png](\images\posts\mysql\-4.png)

---

### c 语言操作数据库

1. mysql_init: mysql_real_connect   背后实际是tcp连接
2.  连接池：数据库的连接是一个资源，类似于内存池与线程池
3. 表太大，查询结果会很大，两台机器返回一个很大的记录很耗时
4. 当发送sql命令后，MySQL做了什么

![-5.png](\images\posts\mysql\-5.png)

---

### Mysql特性

#### Mysql视图

* 定义

       视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。简单的来说视图是由其定义结果组成的表。

* 优点

1. 安全性，针对视图对用户做权限设置；

      2. 查询性能高，可以先把数据准备好在内存，然后针对sql进行查询；

      3. 少修改表的结构，比如尤其业务变迁，需要把a表和b表合并起来，那么此时a表的sql语句和b表的sql语句都需要修改，这样如果创建视图关联a表和b表，那么a表和b表的sql语句都不需要修改

```
create view v_match as select
    -> a.PLAYERNO,a.NAME,MATCHNO,WON,LOST,c.TEAMNO,c.DIVISION
    -> from  PLAYERS a,MATCHES b,TEAMS c;
```

---

#### Mysql触发器

* 概念

是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等

* 作用

其能够实现由主键和外键所不能保证的复杂参照完整性和数据的一致性，它能够对数据库中的相关表进行级联修改，提高比CHECK约束更复杂的的数据完整性，并自定义错误

1. 强制数据库间的引用完整性
2. 级联修改数据库中所有相关的表，自动触发其它与之相关的操作
3. 跟踪变化，撤销或回滚违法操作，防止非法修改数据
4. 返回自定义的错误消息，约束无法返回信息，而触发器可以
5. 触发器可以调用更多的存储过程

---

#### Mysql事务

* 事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的

---

#### Mysql锁

对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁

事务可以通过以下语句显示给记录集加共享锁或排他锁：

* 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
* 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE

共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作

但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁，在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能