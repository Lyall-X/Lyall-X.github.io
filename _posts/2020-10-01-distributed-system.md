---
layout: post
title: 分布式事务
categories: 架构设计
description: 分布式事务
keywords: 分布式事务
---

## 分布式事务专题

### 分布式介绍

#### 事务

- 要么全部成功，要么全部失败；事务一般是通过关系型数据库来控制
- 本地事务：基于关系型数据库的事务
- 分布式系统：把应用系统拆分成可独立部署的多个服务，不同服务通过网络远程协作
- 分布式事务产生场景：跨JVM进程产生分布式事务

1. 微服务架构
2. 单体系统访问多个数据库实例
3. 多服务访问一个数据库实例

#### CAP理论

三者只能存在两个共存

* C：Consistency 一致性
* A：Availability 可用性
* P：Partion tolerance 分区容错性

一致性：任意 的

* 写入主数据库后，要将数据同步到从数据库
* 在同步时要将从数据库锁定
* 特点：
    * 存在同步过程，写操作有延迟
    * 会对资源进行锁定
    * 同步失败的节点会返回错误信息，一定不会返回旧数据

可用性：操作都会得到响应结果，且不会出现响应超时或相应错误

* 不可将数据库中资源锁定
* 特点：
    * 所有请求都有响应，且不会出现响应超时或响应错误

分区容忍性：不同网络分区的服务，出现网络问题时仍可对外提供服务

* 使用异步取代同步操作
* 添加数据库节点，冗余
* 特点：
    * 分区容忍是分布式系统具备的基本能力

#### BASE理论

强一致性：任何时间查询数据都必须一致

最终一致性：可以在某个时间节点不一致，但经过一段时间必须一致

BASE理论介绍：

* Basically Available(基本可用)：保证核心功能
* Soft state(软状态)：中间状态
* Eventually consistent (最终一致性)

柔性事务：满足BASE理论的事务

------

### 分布式解决方案

* 2PC：两阶段提交
* TCC
* 可靠消息最终一致性
* 最大努力

#### 解决方案：2PC（两阶段提交）

2PC：两阶段提交协议

* P：准备阶段
* C：提交阶段

事务管理器与参与者构成

解决方案：

##### XA方案

* DTP：标准组织定义的分布式事务处理模型
* XA：DTP模型定义TM和RM之间通讯的接口规范

* XA方案：基于数据库的XA协议来实现2PC

问题：

* 需要本地数据库支持XA协议
* 资源锁需要等到两个阶段结束才释放，性能较差。

##### Seata方案

开源的分布式事务框架

* Transaction Coordinator (TC)： 事务协调器
  * 维护全局事务的运 行状态

  * 通知各个参与者的提交或回滚

* Transaction Manager (TM)： 事务管理器
  * 嵌入应用程序中，以jar包方式嵌入
  * 收集信息报给TM

* Resource Manager (RM)： 控制分支事务
  * 理解为每一个数据库实例
  * 接受RM

区别

架构层次：

* 传统2PC：在数据库层，通过XA协议实现
* Seata：以jar包的形式作为中间件层部署到应用程序

两阶段提交：

* 传统2PC：事务性资源的锁都要保持到Phase2完成才释放
* Seata：锁提前释放，出错回滚

------

#### 解决方案：TCC

##### TCC

* Try：预处理
  * 业务检查
  * 资源预留

* Confirm：确认
  * 业务确认操作
  * 预处理成功，确认肯定会成功，如果失败会重新尝试
  * 因为会重新尝试，所以代码必须幂等

* Cancel：撤销回滚

Try成功，执行确认

Try失败，执行撤销

TCC需要注意的三种异常：

* 空回滚
  * 由于网络等原因导致
  * 在回滚前需要查询记录，实现空回滚

* 幂等
  * 无论执行多少次，效果都一样
  * 增加执行状态，每次执行前先判断，避免重复执行

* 悬挂
  * Cancel比Try先执行
  * 调用RPC时，网络原因消息晚到达

##### 2PC与TCC比较

* 2PC： 在跨库的DB层面处理
* TCC：在应用层处理，通过业务逻辑来实现

优点：应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能

缺点：

* 于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作
* 实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。

------

#### 解决方案：可靠消息最终一致性

* 指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能 够接收消息并处理事务成功
* 此方案强调的是只要消息发给事务参与方最终事务要达到一致

此方案利用消息中间件

需要解决问题：

1. 本地事务与消息发送的原子性问题
   * 事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息

2. 事务参与方接收消息的可靠性
3. 消息重复消费的问题

解决方案：

##### 本地消息表方案

* 通过本地事务保证数据业务操作和消息的一致性
* 通过定时任务将消息发送至消息中间件
* 待确认消息发送给消费方成功再将消息删除

**RocketMQ事务消息方案**

* 自阿里巴巴的分布式消息中间件