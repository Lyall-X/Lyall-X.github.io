---
layout: post
title: 高可用架构
categories: 架构设计
description: 架构设计
keywords: 架构, 高可用架构
---

## 架构原理

### 架构介绍

**系统整体架构**

* 设备：
    * 硬件 -- 了解硬件特性
    * CDN -- 加速；防攻击
    * DNS -- 采用域名防止dns劫持,浏览器劫持

* 架构分层模型：
    * 接入层 -- 安全，用户访问合法性问题，请求转发
    * 逻辑层 -- 对业务的实现；服务降级
    * 数据层 -- 数据存储；数据备份；存储介质
    * 缓存层 -- 高性能查询服务；数据一致性问题

* 安全：
    * 安全 -- 宕机；劫持；
    * 监控 -- 服务治理
    * 质量保证
    * 性能定位分析 -- 基于语言内存分析

* 案例

### 架构关键节点

* 负载均衡
* 软件质量保证
* 预发布
* 灰度发布
* 安全
* 监控
* 回滚方案
* 线上问题定位分析
* ......

---

**软件架构：在设计原则基础上，对系统的各个部分组合，形成架构***

**一定要基于业务对架构设计；架构高可用是重中之重**

两大要素：

* 各个组件
* 组件间的相关关联

**软件架构对比：**

好的架构：

* 成本最低
* 满足用户需求(将来的功能需求)
* 系统稳定性好(CPU...)
* 架构足够灵活
    * 数据量维度(数据层扩展)
    * 并发量维度
    * 部署运维维度

坏的软件架构：

* 成本较高
* 系统复杂、笨重
* 系统不稳定
    * 经常发生故障

* 系统扩展性差
* 系统维护性差
    * 维护代价高

### 实现架构高可用手段

* 设计无状态化：请求结束后数据消失，不保存状态；任何一台宕机没影响；扩展性好
* 子系统冗余：尽可能冗余，所依赖的不可靠
* 幂等性设计：一次请求与多次请求，结果是一样的称为幂等性设计
* 异步调用：提高并发量，资源利用率高
    * 避免一个服务失败导致的整个服务失败

* 超时机制：避免下游出现问题，上游死等
* 分级管理：系统模块分级管理；好的模块部署好的机器，核心模块尽量完善
* 服务降级：预防ddos工具；同一时刻过多请求；核心服务可以支持，边缘服务支持一部分
* 服务治理
    * 监控：
    * 服务可管理、可视化：

* ......

架构高可用评判标准：

* 任何时间都正常提供读写服务
    * 7*24
    * 机硬件故障
        * CPU、内存、硬盘、网卡
    
    * 机器软件故障
        * OS、 FileSystem……
    
    * 网络划分
        * 机器间网络隔离
        * 网络弱可用

架构高可用评价维度：

* 指系统在面对各种异常时可以提供正常服务的能力
* 系统的可用性可以用系统停服务的时间和正常服务时间的比例来衡量
* 系统不可用时间(故障时间=故障修复时间点-故障发现时间点)
* 4个9的可用性（99.99%）：高可用
    * 具备自动恢复能力的高可用
    * 一年停机的时间不能超过53分钟
    * 365*24*60/10000 = 53分钟

* 3个99的可用性（99.9%）： 较高可用性
* 2个9的可用性（99%）： 基本可用

服务分级：

* 根据标准分级，出现事故可定义影响和责任面

---

思考：

1. 上线发生数据改动，格式和之前不兼容，回滚也不正常，如何处理？
    1. 在任务数据改动前都需要备份
    2. 不建议在老的数据上直接改，可以根据老数据生成一份新数据；如果用的是新数据，直接切换到新流程上，如果是老的数据，就用老的流程

2. 上线更新删除了数据，回滚后数据也没有了，如何处理？
    1. 在数据修改前备份
    2. 设置延迟从；从库延迟执行指令

------

## 架构分层篇

### ALL IN ONE 架构

* 整个架构只有一个模块
  * 数据部分、逻辑部分、接入部分、展示部分等

* 架构存在问题
  * 耦合严重
  * 职责不分明
  * 模块庞大、臃肿
  * 开发成本高、效率低下
  * 运维成本高
  * 组件间相互影响，一旦一个组件有问题，整个服务都受影响
  * 扩展性差
  * 性能极限差
  * 牵一发而动全身！！！！

适用：

* 在创业初期适合，因为人数时间少需要快速设计

---

### 高可用架构

* ALL IN ONE架构问题多多
* 服务高可用需分层设计
* 模块耦合性低
* 模块职责分明
  * 数据层、逻辑层、接入层、展示层等等

* 模块间不再相互影响
* 模块独立扩展
* 系统整体性能高

---

### 高可用架构分层设计原则

**架构分层：真正的物理分层，而不是代码逻辑分层**

* 数据服务和逻辑服务分离
  * 数据存储
  * 业务逻辑

* 逻辑服务和接入服务分离
  * 业务逻辑
  * 接入层

* 接入服务和展示服务分离
  * 接入层
  * 数据展示

**分层效果：**

* 分层服务功能单一
  * 数据
  * 逻辑
  * 接入
  * 展示
  * ……

* 分层间低耦合
  * 接口交互

* 分层内高内聚
  * 功能聚焦单一

**分层级别：**

* 分层适中
  * 层次过多
    * 请求交互路径长
    * 请求响应延迟高
    * 层次多，运维成本高
    * 定位问题涉及层次多，定位复杂多增加，定位时间长

  * 层次过少
    * 每个层次功能不单一，耦合性高
    * 模块内组件间相互影响高
    * 高可用无法保证

---

### 高可用架构分层案例

* 前端架构
  * MVC架构分层

* 后端架构
  * 按照功能水平划分
    * 四层
      * 接入层、逻辑层、数据层、数据存储
      * 接入层、逻辑层、原子服务层、数据存储

    * 五层
      * 接入层、序列化层（异步消息队列）、逻辑层、数据层、数据存储

  * 按照业务垂直拆分
    * 房产、招聘、二手、二手车、黄页
    * IM、交友等

---

#### 如何进行架构分层：

脱离业务场景谈架构分层绝对是耍流氓

架构的分层取决于业务场景：

* MVC
* 三层
* 四层
* 五层

架构的分层取决于业务发展阶段：

* 创业初期
  * 满足业务快速发展
  * 可用性低
  * 分层少
  * ALL IN ONE

* 业务数据量、请求量快速增长期
  * 引入分层
  * 接入层、逻辑层、数据存储等
  * 满足业务增长需求

* 业务请求高并发，海量存储期
  * 每层进一步细化
  * 分布式存储、 NoSQL、 RDBMS分库分表

* 业务多、请求多、关系复杂
  * 58列表页、详情页问题
  * 服务化
  * 解耦、稳定

---

#### 架构演进之路

1. 设计总体四层架构
2. 结合项目背景与开发需求
3. 服务使用背景定位
4. 吞吐量
5. 推送量
6. 功能多
7. 业务复杂
8. 未来扩展
9. 高可用

---

思考：

1. 架构高可用分层带来的潜在问题是什么？（两面性，优点大于缺点）
   1. 分层过多：维护系统复杂性高
   2. 一旦产生分层：定位问题变难

------

## 硬件

### 硬件

* CPU
  * 32 processor(8个物理核，每核2个处理器，开启超线程)
  * 2.5GHZ

* 内存
  * 32G->64G->96G->128G

* 磁盘
  * SATA机械盘->SAS机械盘->SSD(固态硬盘)
  * 价格10倍
  * IO性能50倍
  * 读写速度越来越快
  * 硬件成本原来越高
  * 1TB

* 网卡
  * 100mbs
  * 1000mbs

### 选择硬件

机型分类

* 内存性
* I/O型：本地磁盘IO（SSD，磁盘冗余，针对DB）
* CPU计算型
* ……

#### 硬件的选择取决于业务应用场景

* Web业务场景
  * 内存型/计算型

* 逻辑业务场景
  * 计算型

* Cache应用
  * 内存型

* 测试应用
  * 虚拟机（性能损耗）

* 数据库场景
  * DB存储型（SSD）

* 实时计算场景
  * 存储型-Spark/Storm

* 离线计算场景
  * 存储型-Hadoop

* 海量数据存储（文件、图片等）:分布式文件系统
  * 存储型-Public

* 图像识别计算场景
  * 计算型（GPU)

* 线下、边缘业务场景
  * 虚拟机
    * 物理隔离
    * 性能消耗

---

### 磁盘的高可用

* SATA->SCSI->SAS->SSD
* 性能越来越好
* 价格越来越高
* 可用性越来越高
* 尽可能选用高可用的磁盘
* 单磁盘可用性依然保证不了，怎么办

单机下

磁盘的高可用性如何保证：

* 用户对磁盘系统的五大要求
  * 速度：提高磁盘I/O存取速度，缩小内存和磁盘的性能差距
  * 安全性：增强数据安全性及容错能力
  * 空间利用率：有效利用磁盘空间（冗余）
  * CPU占用率：降低数据I/O对CPU资源的占用
  * 性能：提高计算系统的整体工作性能

* RAID（ Redundant Arrays of Independent Disks ）
  * 磁盘阵列 -- 磁盘冗余
    * 独立磁盘构成的具有冗余能力的阵列
    * 由很多价格较便宜的磁盘组成容量较大的磁盘组
    * 并行读写，提升性能
    * 数据恢复能力，任意磁盘故障，可以读出数据，数据重构植入新硬盘

* RAID的各种磁盘组成方式
  * RAID0
    * 数据分条：可以并行加速数据读写，但不具备数据冗余

  * RAID1
    * 冗余：数据备份，没有数据粉条

  * RAID10
    * RAID1+RAID0：具备数据分条与数据冗余；用的最多

  * RAID01
    * RAID0+RAID1：比RAID10读写速度更快；但是如果坏会坏一组，所以在数据高可用上用的少

  * RAID5
    * 分布式奇偶校验独立磁盘
    * 实际数据与校验数据是放在不通的数据盘上
    * 挂了其中一个，校验磁盘会进行回复

![064777467ff12ada5a803fa826b65217.png](\images\posts\architecture\064777467ff12ada5a803fa826b65217.png)

单机

* RAID
  * 系统
    * 存储数据
    * SAS

  * 系统（不拥有数据）
    * 不用RAID

  * 数据库
    * 固化
    * SSD

磁盘整体故障或者机器故障怎么保证高可用性？

我们的RAID优化

* Stripe Element Size （磁条元素大小）：指定了在 RAID 0、 1、 5、 10 和 50 虚拟
* 读写策略： force wb with no battery（不使用电池强制回写）

多机下

* 系统多机冗余
* 数据多机冗余
* 保证高可用性

---

### 硬件部署实践：

机器

* 普通PC服务器
  * R410、 R420、 C6100、 R710、 R720、 1950、 R720等等
  * 内存型（内存大，比如128GB）
  * 硬盘型（SATA->SAS->SSD）
  * CPU计算型（2.5GHZ 16core->32core->64core->128core）

* 硬盘
  * RAID0、 RAID1、 RAID10、 RAID5
  * 模块机器不做冗余
  * RAID10

多机冗余

* 模块
  * 至少2个节点，需要多少，取决于整体系统吞吐量和单机吞度量

* 存储
  * Master-Salver：主从同步
  * Replic-Sets：Mongdb

------

## DNS

### DNS(Domain Name System)

* 所有域名记录由DNS服务器集群存储
* 用户计算机不用存储所有的域名->IP映射， hosts文件不大
* 规定了域名的命令规则，保证了主机名字不会重复
* DNS是一个层次的的分布式数据库服务集群
* 权威域名服务器
  * DNS Zone

* 根域名服务器
  * ROOT

---

DNS查询：

dig命令查询A记录

* dig www.baidu.com -t A +short

dig解析路径查询

* dig www.58.com +trace
* 查询从根域名到指定域名可能经过的所有域名服务器

---

### 两种针对于DNS的攻击

#### 1.DNS劫持：

* 区域域名服务器负责用户解析请求
* 没有机制保证域名映射是否准确
* “流氓的域名服务器” 更改一些域名的解析结果
* 或者区域域名服务器被黑客攻击，恶意修改
* 引导用户一个错误的目标IP地址
* 这就是DNS劫持
* 劫持目标
  * 阻止用户访问某些特定网站
  * 引导用户到广告页面

验证是否被DNS劫持：

* nslookup命令（linux）
  * nslookup www.baidu.com
  * whois 61.135.169.121
  * » 看看是不是百度的

#### 2.DNS欺骗：

* 用一个假的DNS应答来欺骗DNS请求用户
* 让其相信返回的假地址， 并抛弃真正的DNS应答
* 用户主机发出DNS请求后，等待应答
* 如果此时有一个看起来正确的应答包（拥有和DNS请求一样的序列号）， TA信以为真
* 这个DNS欺骗的关键在于伪造一个特定序列号的应答包

验证是否被DNS欺骗：

* 同DNS劫持方案
* nslookup查询
  * IP
  * whois确定ip拥有方
  * 根据IP查询拥有方

------

## CND篇

### CDN系统架构高可用涉及技术点

* CDN(Content Delivery Network)：内容分发网络
* 将内容从源站传输到用户端
* 加速网站访问速度
* 静态资源缓存

### CDN架构

* Local DNS
  * CDN DNS CNAME

* CDN DNS
  * 获取全局负载均衡IP
  * 获取局部负载均衡IP
  * 找到最优CDN节点IP
  * 全局负载均衡服务把CDN节点IP返给用户

* 用户请求CDN节点，获取数据
  * 没有数据请求上一级缓存
  * 直到源服务器节点

------

## 接入层

### 接入层作用

* 客户端海量长/短连接管理
  * TCP/HTTP[S]

* 建立与客户端通信的加密通道
* 数据合法性、正确性校验
* 整合成内部少量的长连接
* Session的管理
* 实施初步的攻防
* 请求转发到逻辑层

Session是什么

* 读写请求使用的上下文对象，称之会话(Session)
* 高可用架构需要服务无状态，但是Session一般是有状态的(因为要记录业务)，所有需要做到Session同步

---

### Session复制

* 集群的所有接入层服务器之间同步Session数据
* 每台接入服务器都保存用户全量的Session数据
* 用户请求只需要访问其中一台机器，获取速度快
* 高可用保障
  * 宕机部分机器，没影响

存在问题：

* 适用于接入层集群较少
* 接入层集群量大
  * 大量的Session复制通信，占用服务器和网络资源
  * 每台机器存储全量用户Session，内存占用量大，甚至Out Of Memory
  * 大型网站接入层数千台，同时在线用户达到千万（ IM)，不适合

### 解决方法

Session绑定：（绑定之后的session部分集群进行复制）

* 根据用户请求（UID、 Mac、 imei等用户唯一标示)负载均衡到特定接入层
  * HASH(ID)
    * uid%Num

* 特定用户请求路由到特定接入层服务器
* 部分网站使用
* 高可用如何保障
  * 单点问题
  * 复制机制
    * Master-Slave

---

### Session高可用集群

* 接入层无状态化
* 统一的高可用Session服务器
* 接入层分布式读写Session集群
* 状态分离：在Nginx与Session中间加入了接入层
  * 接入层本身无状态
  * Session集群有状态
    * 分布式缓存
      * NoSQL（Memcached/Redis）
      * RDBMS（MySQL/MongoDB）

模块和数据分离：

* 接入层模块无状态
  * 动态线性伸缩
  * 冗余

* Session数据统一分布式存储
  * 数据冗余保证
  * 高可用性保证

![848e94a0569d3346a3b9582c14bef380.png](\images\posts\architecture\848e94a0569d3346a3b9582c14bef380.png)

---

**接入层安全性**

* 接入层是客户端和服务端的Interface
* 数据安全重要性不言而喻
* 保证数据安全性
  * 连接通道加密
  * 传输数据加密

传输加密：

* 客户端和服务器之间的所有请求(传输数据)都必须加密，提高效率，
  * 对称加密密钥使用非对称加密算法经过两次协商确定
  * 安全信道的建立必须满足

* 任何第三方无法伪造服务器
* 在破解客户端代码的情况下，即使截获其他用户发送的加密请求，也无

------

## 业务逻辑

### 逻辑层设计实践：

* 无状态
* 冗余部署
* 异步
* 超时机制
* 请求分级
* 幂等设计
* 高性能

---

### 逻辑层整体架构：

ALL IN ONE（业务垂直划分）方式

* 业务垂直划分
  * 一个单独业务一个组件（目录和文件）

* 优点
  * 业务独立
  * 耦合性降低
  * 业务之间开发互不影响
  * 开发效率高
  * 运维相对简单

* 缺点
  * 物理上一个模块
  * 编译成本高
  * 一个业务修改，重新上线
  * 重启影响所有业务

* 适用场景
  * 互联网公司使用较多
  * 58
  * 百度

---

业务间物理垂直划分方式：

* 业务间物理垂直划分方式
* 每个业务一个独立的业务模块（进程）

### 什么是无状态

* 系统不存储业务的上下文信息
* 仅根据每次请求携带数据进行相应的业务逻辑处理
* 多个模块（子系统）之间完全对称
* 请求提交到任何服务器，处理结果都是完全一样

#### 无状态设计关键因素：

* 业务逻辑层不保存请求状态
* 业务逻辑层不保存数据
* 所有业务逻辑层服务器完全对称
* 当一台或者多台宕机
* 请求提交到集群中的任意可用服务器
* 业务逻辑层高可用
* 实现高可用的关键因素是什么？
  * 负载均衡

---

#### 负载均衡：

* 服务器可用状态实时监测的机制
* 自动转移失败任务(机器)的机制
* 请求量和数据量较高，将流量和数据分摊到集群中多台服务器的能力
* 通过
* 一旦服务器可用，可以自动重连恢复

---

#### 异步调用： 消息队列

* 通过消息队列（缓冲、持久化、解决异步）实现异步调用

#### 异步调用场景：

* I/O
* 特别是网络I/O
* I/O模型
  * 阻塞I/O模型(同步阻塞)
  * 轮询非阻塞I/O模型(不停的问好了没好)
  * I/O复用模型(select, poll, epoll)

#### 高性能纯异步网络调用设计

* server端连接池+server端收发队列；
* client端连接池+client端收发队列；
* 超时队列与超时管理器；
* 上下文管理器+状态机；

---

### 服务分级管理：

#### 硬件分级层面

* 核心系统使用好的机器、
  * CPU、内存、磁盘、网卡

* 边缘系统使用差的机器

#### 部署层面

* 服务部署隔离
* 避免故障带来的连锁反应
* 核心系统部署在物理机上
* 核心系统部署不同的机房
* 边缘系统部署虚拟机
* 边缘系统公用机器

---

#### 设置合理超时：

* 业务逻辑层和下游模块交互次数多
* 设置合理超时非常重要
* 下游服务宕机、线程死锁等，请求得到不到响应
* 请求占用资源
* 调用方得不到响应，用户体验糟糕

#### 如何设置超时：

* 请求的超时设置根据请求的平均响应延迟
  * 经验值
    * 超时时间是平均响应延迟的2倍，避免过长时间等待

  * 响应延迟高，超时时间设置长些
    * 3S

  * 响应延迟低，超时时间设置短些
    * 100MS

* 下游请求超时后，业务层根据预设的调度策略
* 继续重试
  * 一般3次
  * 多次无好处

* 请求转移到下游其他同样服务上

---

### 业务逻辑层服务降级设计：

* 网站高峰期，并发量大
  * 服务能力有限
  * 性能下降
  * 服务宕机
  * 系统雪崩情况

* 怎么办？
  * 服务降级

#### 如何服务降级：

* 保证核心服务可用
* 非核心服务弱可用，甚至不可用
* 降级设计方案
  * 拒绝部分请求
  * 关闭请求

#### 具体降级实现：

拒绝部分请求

* 拒绝低优先级服务的调用
* 减少服务调用并发数
* 确保核心服务正常使用
* 队列方式
  * 入队、出队时间，超过一定时间，直接丢弃

* 优先级请求方式
  * 非核心请求直接丢弃
  * 例如商城丢弃评论留言功能

* 随机拒绝方式(所有请求同优先级)
  * 随机丢弃一定比例请求
  * 网站一会可用，一会不可用，大都是这样的处理

#### 关闭部分服务

* 非核心服务直接关闭
* 业务逻辑层屏蔽掉
* 不再调用
* 节约系统开销
* 保证核心服务的正常响应
* 秒杀活动
* 双11.11活动
  * 关闭社交

---

### 服务器幂等设计：

* 请求失败后，会继续重试
  * 各种失败原因

* 保证服务重复调用和一次调用结果相同（幂等性）
* 不能保证幂等性
  * 结果将是灾难性的
    * 转账
    * 交易
    * 支付

##### 如何做到幂等设计：

* 天然幂等
  * 离线消息设置为已读
    * 多次设置都是一样

* 非幂等->幂等设计（额外增加状态或记录）
  * 支付
    * 支付ID，支付状态
    * 每次支付前，判断支付状态，未支付状态继续进行，已支付了就中止

  * 转账
    * 转账状态判断

------

## 数据存储

### 单机存储引擎：

* 存储引擎类型
  * 哈希存储引擎
  * B树存储引擎
  * LSM存储引擎

### 哈希存储引擎

* 基于哈希表结构的键值存储系统
* 数组+链表
* 支持Create、 Update、 Delete、随机Read
* O(1)Read复杂度

### B树存储引擎

* 基于B Tree实现
* 支持单条记录的CURD
* 还支持顺序扫描、范围查找
* RDBMS使用较多
  * MySQL
  * InnoDB 聚簇索引
  * B+树

### LSM树存储引擎

* Log Structured Merge Tree
* 对数据的修改增量保存在内存中，达到指定条件后（通常是数量和时间间隔），批量将更新操作持
* 读取数据时需要合并磁盘中的历史数据和内存中最近修改操作
* LSM优势在于通过批量写入，规避了随机写入问题，提高写入性能
* LSM劣势在于读取需要合并磁盘数据和内存数据
* 如何避免内存数据丢失？
  * Commit Log
  * 首先将修改操作写入到Commit Log中
  * 操作数据的可靠性保证

* 典型案例设计
  * LevelDB

---

### 多机存储原理与设计

* 单机存储与多机存储
  * 单机存储的原理在多机存储仍然可用
  * 多级存储基于单机存储

* 多机数据分布
  * 区别于单机存储
  * 数据分布在多个节点上，在多个节点之间需要实现负载均衡
  * 数据分布方式
    * 静态方式
      * 取模（下游出现问题或者增加机器，无法无缝迁移）
      * uid%32

    * 动态方式
      * 一致性hash
      * 数据飘移问题（网络抖动吗，导致数据来回在两个数据库中写）
        * 可以增加时间戳。，到期后丢弃

#### 存储复制：

* 分布式存储多个副本
* 保证了高可靠和高可用
* Commit Log

#### 故障检测：

* 心跳机制
* 数据迁移
* 故障恢复

FLP定理与设计 --> CAP定理与设计